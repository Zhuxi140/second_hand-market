# 仿闲鱼项目技术实现计划

## 1. 项目架构设计

### 1.1 整体架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端 (Vue3)   │    │   移动端 (可选)  │    │   管理后台      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
                    ┌─────────────────┐
                    │  Spring Boot    │
                    │   后端服务      │
                    └─────────────────┘
                                 │
         ┌───────────────────────┼───────────────────────┐
         │                       │                       │
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│     MySQL       │    │     Redis       │    │   RabbitMQ      │
│   主数据库      │    │    缓存层       │    │   消息队列      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 1.2 技术栈选择

- **后端框架**：Spring Boot 2.7+
- **ORM框架**：MyBatis 3.5+
- **数据库**：MySQL 8.0
- **缓存**：Redis 6.0+
- **消息队列**：RabbitMQ 3.8+
- **认证**：Spring Security + JWT
- **构建工具**：Maven 3.6+

## 2. 项目结构设计

### 2.1 包结构

```
com.example.secondhand
├── config/                 # 配置类
│   ├── SecurityConfig.java
│   ├── RedisConfig.java
│   └── RabbitMQConfig.java
├── controller/             # 控制器层
│   ├── AuthController.java
│   ├── UserController.java
│   ├── ProductController.java
│   ├── OrderController.java
│   └── AdminController.java
├── service/                # 服务层
│   ├── UserService.java
│   ├── ProductService.java
│   ├── OrderService.java
│   └── ChatService.java
├── mapper/                 # 数据访问层
│   ├── UserMapper.java
│   ├── ProductMapper.java
│   └── OrderMapper.java
├── entity/                 # 实体类
│   ├── User.java
│   ├── Product.java
│   └── Order.java
├── dto/                    # 数据传输对象
│   ├── UserDTO.java
│   ├── ProductDTO.java
│   └── OrderDTO.java
├── common/                 # 公共组件
│   ├── Result.java
│   ├── PageResult.java
│   └── JwtUtil.java
├── exception/              # 异常处理
│   ├── GlobalExceptionHandler.java
│   └── BusinessException.java
└── utils/                  # 工具类
    ├── FileUtil.java
    └── DateUtil.java
```

### 2.2 数据库设计优化

#### 2.2.1 核心表结构

```sql
-- 用户表（简化版）
CREATE TABLE `user` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
  `username` VARCHAR(25) NOT NULL,
  `password` VARCHAR(64) NOT NULL,
  `nickname` VARCHAR(25),
  `phone` VARCHAR(18) NOT NULL,
  `avatar` VARCHAR(255),
  `status` TINYINT UNSIGNED NOT NULL DEFAULT 1,
  `created_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_username` (`username`),
  UNIQUE KEY `uk_phone` (`phone`)
);

-- 商品表（简化版）
CREATE TABLE `product` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
  `seller_id` BIGINT UNSIGNED NOT NULL,
  `title` VARCHAR(50) NOT NULL,
  `description` TEXT,
  `category_id` BIGINT UNSIGNED NOT NULL,
  `price` DECIMAL(12, 2) NOT NULL,
  `condition` TINYINT UNSIGNED NOT NULL,
  `status` TINYINT UNSIGNED NOT NULL DEFAULT 1,
  `location` VARCHAR(50),
  `view_count` INT UNSIGNED NOT NULL DEFAULT 0,
  `created_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_seller_id` (`seller_id`),
  KEY `idx_category_id` (`category_id`)
);
```

## 3. 核心功能实现

### 3.1 用户认证模块 🔴

#### 3.1.1 JWT认证实现

```java
@Component
public class JwtUtil {
    private static final String SECRET = "mySecretKey";
    private static final int EXPIRE_TIME = 7 * 24 * 60 * 60 * 1000; // 7天
  
    public String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRE_TIME))
                .signWith(SignatureAlgorithm.HS512, SECRET)
                .compact();
    }
  
    public String getUsernameFromToken(String token) {
        return Jwts.parser()
                .setSigningKey(SECRET)
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }
}
```

#### 3.1.2 Spring Security配置

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
  
    @Autowired
    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
  
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .authorizeRequests()
            .antMatchers("/api/v1/auth/**").permitAll()
            .antMatchers("/api/v1/products/**").permitAll()
            .anyRequest().authenticated()
            .and()
            .exceptionHandling().authenticationEntryPoint(jwtAuthenticationEntryPoint)
            .and()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
      
        http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);
    }
}
```

### 3.2 商品管理模块 🔴

#### 3.2.1 商品服务实现

```java
@Service
@Transactional
public class ProductService {
  
    @Autowired
    private ProductMapper productMapper;
  
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
  
    public PageResult<Product> getProductList(ProductQueryDTO queryDTO) {
        // 使用PageHelper分页
        PageHelper.startPage(queryDTO.getPage(), queryDTO.getSize());
        List<Product> products = productMapper.selectByCondition(queryDTO);
        PageInfo<Product> pageInfo = new PageInfo<>(products);
      
        return PageResult.<Product>builder()
                .list(products)
                .total(pageInfo.getTotal())
                .page(queryDTO.getPage())
                .size(queryDTO.getSize())
                .build();
    }
  
    @Cacheable(value = "product", key = "#productId")
    public Product getProductById(Long productId) {
        return productMapper.selectById(productId);
    }
  
    public void publishProduct(ProductDTO productDTO) {
        Product product = new Product();
        BeanUtils.copyProperties(productDTO, product);
        product.setSellerId(getCurrentUserId());
        productMapper.insert(product);
      
        // 清除相关缓存
        redisTemplate.delete("product:list:*");
    }
}
```

#### 3.2.2 文件上传实现

```java
@RestController
@RequestMapping("/api/v1/upload")
public class UploadController {
  
    @Value("${file.upload.path}")
    private String uploadPath;
  
    @PostMapping("/image")
    public Result<String> uploadImage(@RequestParam("file") MultipartFile file) {
        try {
            // 文件验证
            if (file.isEmpty()) {
                throw new BusinessException("文件不能为空");
            }
          
            // 生成文件名
            String fileName = UUID.randomUUID().toString() + 
                            file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf("."));
          
            // 保存文件
            File dest = new File(uploadPath + fileName);
            file.transferTo(dest);
          
            return Result.success("/images/" + fileName);
        } catch (IOException e) {
            throw new BusinessException("文件上传失败");
        }
    }
}
```

### 3.3 订单管理模块 🔴

#### 3.3.1 订单服务实现

```java
@Service
@Transactional
public class OrderService {
  
    @Autowired
    private OrderMapper orderMapper;
  
    @Autowired
    private ProductMapper productMapper;
  
    @Autowired
    private RabbitTemplate rabbitTemplate;
  
    public void createOrder(OrderCreateDTO orderDTO) {
        // 1. 验证商品状态
        Product product = productMapper.selectById(orderDTO.getProductId());
        if (product.getStatus() != ProductStatus.ON_SALE) {
            throw new BusinessException("商品已下架");
        }
      
        // 2. 创建订单
        Order order = new Order();
        order.setBuyerId(getCurrentUserId());
        order.setTotalAmount(product.getPrice());
        order.setStatus(OrderStatus.PENDING_PAYMENT);
        orderMapper.insert(order);
      
        // 3. 创建订单明细
        OrderDetail orderDetail = new OrderDetail();
        orderDetail.setOrderId(order.getId());
        orderDetail.setProductId(product.getId());
        orderDetail.setSellerId(product.getSellerId());
        orderDetail.setQuantity(1);
        orderDetail.setUnitPrice(product.getPrice());
        orderMapper.insertOrderDetail(orderDetail);
      
        // 4. 更新商品状态
        product.setStatus(ProductStatus.RESERVED);
        productMapper.updateById(product);
      
        // 5. 发送消息到队列
        rabbitTemplate.convertAndSend("order.exchange", "order.created", order.getId());
    }
  
    public void cancelOrder(Long orderId) {
        Order order = orderMapper.selectById(orderId);
        if (order.getStatus() != OrderStatus.PENDING_PAYMENT) {
            throw new BusinessException("订单状态不允许取消");
        }
      
        // 更新订单状态
        order.setStatus(OrderStatus.CANCELLED);
        orderMapper.updateById(order);
      
        // 恢复商品状态
        List<OrderDetail> details = orderMapper.selectOrderDetailsByOrderId(orderId);
        for (OrderDetail detail : details) {
            Product product = productMapper.selectById(detail.getProductId());
            product.setStatus(ProductStatus.ON_SALE);
            productMapper.updateById(product);
        }
    }
}
```

### 3.4 缓存优化 🔴

#### 3.4.1 Redis配置

```java
@Configuration
@EnableCaching
public class RedisConfig {
  
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
      
        // 设置序列化器
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
      
        template.afterPropertiesSet();
        return template;
    }
  
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(30))
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
      
        return RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
    }
}
```

#### 3.4.2 缓存使用示例

```java
@Service
public class ProductService {
  
    @Cacheable(value = "hotProducts", key = "'list'")
    public List<Product> getHotProducts() {
        return productMapper.selectHotProducts();
    }
  
    @CacheEvict(value = "hotProducts", key = "'list'")
    public void updateProduct(Product product) {
        productMapper.updateById(product);
    }
}
```

### 3.5 消息队列实现 🟡

#### 3.5.1 RabbitMQ配置

```java
@Configuration
public class RabbitMQConfig {
  
    @Bean
    public Queue orderQueue() {
        return new Queue("order.queue", true);
    }
  
    @Bean
    public TopicExchange orderExchange() {
        return new TopicExchange("order.exchange", true, false);
    }
  
    @Bean
    public Binding orderBinding() {
        return BindingBuilder.bind(orderQueue()).to(orderExchange()).with("order.*");
    }
}
```

#### 3.5.2 消息监听器

```java
@Component
public class OrderMessageListener {
  
    @Autowired
    private EmailService emailService;
  
    @RabbitListener(queues = "order.queue")
    public void handleOrderCreated(Long orderId) {
        // 发送订单创建通知邮件
        emailService.sendOrderNotification(orderId);
    }
}
```

## 4. 开发计划

### 4.1 第一阶段：基础功能（4-6周）🔴

#### Week 1-2：项目搭建 + 用户管理

- [ ] Spring Boot项目初始化
- [ ] 数据库设计和建表
- [ ] 用户注册、登录功能
- [ ] JWT认证实现
- [ ] 用户信息管理
- [ ] 地址管理功能

#### Week 3-4：商品管理

- [ ] 商品发布功能
- [ ] 商品列表展示
- [ ] 商品详情页面
- [ ] 商品编辑、删除
- [ ] 图片上传功能
- [ ] 商品分类管理

#### Week 5-6：交易功能

- [ ] 商品收藏功能
- [ ] 订单创建流程
- [ ] 订单管理功能
- [ ] 基础搜索功能
- [ ] Redis缓存优化

### 4.2 第二阶段：增强功能（2-3周）🟡

#### Week 7-8：通讯和评价

- [ ] WebSocket聊天功能
- [ ] 交易评价系统
- [ ] 系统管理后台
- [ ] RabbitMQ消息队列

#### Week 9：优化和测试

- [ ] 性能优化
- [ ] 功能测试
- [ ] 部署上线

## 5. 技术难点和解决方案

### 5.1 性能优化

- **数据库优化**：合理使用索引，避免N+1查询
- **缓存策略**：Redis缓存热点数据
- **分页优化**：使用PageHelper实现高效分页

### 5.2 并发处理

- **乐观锁**：处理商品库存并发问题
- **分布式锁**：使用Redis实现分布式锁
- **消息队列**：异步处理耗时操作

### 5.3 安全防护

- **SQL注入防护**：使用MyBatis预编译语句
- **XSS防护**：前端输入验证和转义
- **CSRF防护**：Spring Security CSRF保护

## 6. 部署方案

### 6.1 开发环境

```yaml
# application-dev.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/secondhand?useUnicode=true&characterEncoding=utf8
    username: root
    password: 123456
  redis:
    host: localhost
    port: 6379
  rabbitmq:
    host: localhost
    port: 5672
    username: guest
    password: guest
```

### 6.2 生产环境

```dockerfile
# Dockerfile
FROM openjdk:8-jre-alpine
COPY target/secondhand-1.0.0.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

### 6.3 部署脚本

```bash
#!/bin/bash
# deploy.sh
docker build -t secondhand:latest .
docker stop secondhand-app
docker rm secondhand-app
docker run -d --name secondhand-app -p 8080:8080 secondhand:latest
```

## 7. 面试准备要点

### 7.1 技术亮点

- **Spring Boot**：自动配置、starter机制
- **MyBatis**：动态SQL、缓存机制
- **Redis**：缓存设计、数据结构选择
- **RabbitMQ**：消息队列、异步处理
- **JWT**：无状态认证、安全性

### 7.2 项目亮点

- **完整业务闭环**：从注册到交易的完整流程
- **性能优化**：缓存、分页、索引优化
- **并发处理**：乐观锁、分布式锁
- **扩展性设计**：模块化、可扩展架构

### 7.3 问题准备

- 如何解决商品库存并发问题？
- Redis缓存策略如何设计？
- 如何保证订单数据一致性？
- 系统性能如何优化？
- 如何设计可扩展的架构？
